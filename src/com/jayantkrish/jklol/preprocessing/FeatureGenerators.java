package com.jayantkrish.jklol.preprocessing;

import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Map;

import com.google.common.base.Function;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.jayantkrish.jklol.parallel.MapReduceConfiguration;
import com.jayantkrish.jklol.parallel.MapReduceExecutor;
import com.jayantkrish.jklol.parallel.Mapper;
import com.jayantkrish.jklol.parallel.Reducer;
import com.jayantkrish.jklol.util.CountAccumulator;

/**
 * Utilities for manipulating {@link FeatureGenerator}s.
 * 
 * @author jayantk
 */
public class FeatureGenerators {

  /**
   * Combines many {@code FeatureGenerator}s into a single
   * {@code FeatureGenerator}. The returned generator returns the union of all
   * features generated by {@code generators}. If multiple generators output the
   * same feature, the returned generator sums their counts.
   */
  public static <A, B> FeatureGenerator<A, B> combinedFeatureGenerator(
      Iterable<FeatureGenerator<A, B>> generators) {
    return new CombinedFeatureGenerator<A, B>(generators);
  }

  /**
   * See {@link #combinedFeatureGenerator(Iterable)}.
   * 
   * @param generators
   * @return
   */
  public static <A, B> FeatureGenerator<A, B> combinedFeatureGenerator(
      FeatureGenerator<A, B>... generators) {
    return FeatureGenerators.combinedFeatureGenerator(Arrays.asList(generators));
  }

  /**
   * Constructs features from several {@code FeatureGenerators} by taking
   * products of their generated features (e.g., if the generated features are
   * indicators, this constructs features which are the logical AND of the
   * generated features). This operation will dramatically increase the size
   * number of generated features.
   * 
   * @return
   */
  public static <A, B> FeatureGenerator<A, List<B>> productFeatureGenerator(
      Iterable<FeatureGenerator<A, B>> generators) {
    return new ProductFeatureGenerator<A, B>(generators);
  }

  /**
   * See {@link #productFeatureGenerator(Iterable)}.
   * 
   * @param generators
   * @return
   */
  public static <A, B> FeatureGenerator<A, List<B>> productFeatureGenerator(
      FeatureGenerator<A, B>... generators) {
    return FeatureGenerators.productFeatureGenerator(Arrays.asList(generators));
  }
  
  /**
   * Gets a feature generator that first converts the data,
   * then applies a given feature generator. 
   *  
   * @param generator
   * @param converter
   * @return
   */
  public static <A, B, C> FeatureGenerator<A, C> convertingFeatureGenerator(
      FeatureGenerator<B, C> generator, Function<A, B> converter) {
    return new ConvertingFeatureGenerator<A, B, C>(generator, converter);
  }
  
  /**
   * Gets a feature generator that applies a generator, then
   * applies a converter to the generated feature names. 
   *  
   * @param generator
   * @param converter
   * @return
   */
  public static <A, B, C> FeatureGenerator<A, C> postConvertingFeatureGenerator(
      FeatureGenerator<A, B> generator, Function<B, C> converter) {
    return new PostConvertingFeatureGenerator<A, B, C>(generator, converter);
  }

  /**
   * Applies {@code featureGenerator} to each data point and
   * returns the sum of the resulting feature vectors. 
   *
   * @param featureGenerator
   * @param data
   * @return
   */
  public static <A, B> CountAccumulator<B> getFeatureCounts(FeatureGenerator<A, B> featureGenerator,
      Collection<? extends A> data) {
    MapReduceExecutor executor = MapReduceConfiguration.getMapReduceExecutor();
    Mapper<A, Map<B, Double>> mapper = new FeatureCountMapper<A, B>(featureGenerator);
    Reducer<Map<B, Double>, CountAccumulator<B>> reducer = new FeatureCountReducer<B>();
    return executor.mapReduce(data, mapper, reducer);
  }

  /**
   * Combines many {@code FeatureGenerator}s into a single
   * {@code FeatureGenerator} which returns the sum of each base generator's
   * feature counts.
   * 
   * @author jayantk
   * @param <A>
   * @param <B>
   */
  private static class CombinedFeatureGenerator<A, B> implements FeatureGenerator<A, B> {
    private static final long serialVersionUID = 1L;
    
    private final Iterable<FeatureGenerator<A, B>> generators;

    public CombinedFeatureGenerator(Iterable<FeatureGenerator<A, B>> generators) {
      this.generators = generators;
    }

    @Override
    public Map<B, Double> generateFeatures(A item) {
      CountAccumulator<B> featureCounts = CountAccumulator.create();
      for (FeatureGenerator<A, B> generator : generators) {
        featureCounts.increment(generator.generateFeatures(item));
      }
      return featureCounts.getCountMap();
    }
  }
  
  private static class ProductFeatureGenerator<A, B> implements FeatureGenerator<A, List<B>> {
    private static final long serialVersionUID = 1L;

    private final List<FeatureGenerator<A, B>> generators;

    public ProductFeatureGenerator(Iterable<FeatureGenerator<A, B>> generators) {
      this.generators = Lists.newArrayList(generators);
    }

    @Override
    public Map<List<B>, Double> generateFeatures(A item) {
      // Generate features for each wrapped generator.
      List<Map<? extends B, Double>> generatedFeatures = Lists.newArrayList();
      List<B> currentKey = Lists.newArrayList();
      for (FeatureGenerator<A, B> generator : generators) {
        generatedFeatures.add(generator.generateFeatures(item));
        currentKey.add(null);
      }
      
      // Return the products of all generated features.
      Map<List<B>, Double> counts = Maps.newHashMap();
      recursivelyPopulateCounts(0, generatedFeatures, currentKey, 1.0, counts);
      return counts;
    }
    
    private void recursivelyPopulateCounts(int index, List<Map<? extends B, Double>> generatedFeatures, 
        List<B> currentKey, double currentWeight, Map<List<B>, Double> counts) {
      if (index >= generators.size()) {
        counts.put(ImmutableList.copyOf(currentKey), currentWeight);
        return;
      } else {
        Map<? extends B, Double> currentFeatures = generatedFeatures.get(index);
        for (B key : currentFeatures.keySet()) {
          currentKey.set(index, key);
          recursivelyPopulateCounts(index + 1, generatedFeatures, currentKey, currentWeight * currentFeatures.get(key), counts);
        }
      }
    }
  }
  
  private static class ConvertingFeatureGenerator<A, B, C> implements FeatureGenerator<A, C> {
    private static final long serialVersionUID = 1L;

    private final FeatureGenerator<B, C> generator;
    private final Function<A, B> converter;

    public ConvertingFeatureGenerator(FeatureGenerator<B, C> generator, Function<A, B> converter) {
      this.generator = Preconditions.checkNotNull(generator);
      this.converter = Preconditions.checkNotNull(converter);
    }

    @Override
    public Map<C, Double> generateFeatures(A item) {
      return generator.generateFeatures(converter.apply(item));
    }
  }
  
  private static class PostConvertingFeatureGenerator<A, B, C> implements FeatureGenerator<A, C> {
    private static final long serialVersionUID = 1L;

    private final FeatureGenerator<A, B> generator;
    private final Function<B, C> converter;

    public PostConvertingFeatureGenerator(FeatureGenerator<A, B> generator, Function<B, C> converter) {
      this.generator = Preconditions.checkNotNull(generator);
      this.converter = Preconditions.checkNotNull(converter);
    }

    @Override
    public Map<C, Double> generateFeatures(A item) {
      Map<B, Double> features = generator.generateFeatures(item);
      
      Map<C, Double> convertedFeatures = Maps.newHashMap();
      for (B key : features.keySet()) {
        convertedFeatures.put(converter.apply(key), features.get(key));
      }
      return convertedFeatures;
    }
  }
  
  private static class FeatureCountMapper<A, B> extends Mapper<A, Map<B, Double>> {
    private final FeatureGenerator<A, B> featureGenerator;
    
    public FeatureCountMapper(FeatureGenerator<A, B> featureGenerator) {
      super();
      this.featureGenerator = featureGenerator;
    }

    @Override
    public Map<B, Double> map(A item) {
      return featureGenerator.generateFeatures(item);
    }
  }
  
  private static class FeatureCountReducer<B> implements Reducer<Map<B, Double>, CountAccumulator<B>> {

    @Override
    public CountAccumulator<B> getInitialValue() {
      return CountAccumulator.create();
    }

    @Override
    public CountAccumulator<B> reduce(Map<B, Double> item,
        CountAccumulator<B> accumulated) {
      accumulated.increment(item);
      return accumulated;
    }

    @Override
    public CountAccumulator<B> combine(CountAccumulator<B> other,
        CountAccumulator<B> accumulated) {
      accumulated.increment(other);
      return accumulated;
    }
  }
}
